/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. R:\sandbox\net.bd.gdlc\src\runtime\parser\GdlGrammar.jj */
/*@egen*//*
 */

options {                                    
  STATIC = false;
}

PARSER_BEGIN(GdlParser)

package runtime.parser;

import runtime.parser.DumpVisitor;

public class GdlParser/*@bgen(jjtree)*/implements GdlParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTGdlParserState jjtree = new JJTGdlParserState();

/*@egen*/

  public static void main(String args[]) {
    GdlParser parser;
    if (args.length == 0) {
      System.out.println("Guideline Parser :  Reading from standard input . . .");
      parser = new GdlParser(System.in);
    } else if (args.length == 1) {
      System.out.println("Guideline Parser :  Reading from file " + args[0] + " . . .");
      try {
        parser = new GdlParser(new java.io.FileInputStream(args[0]));
      } catch (java.io.FileNotFoundException e) {
        System.out.println("Guideline Parser :  File " + args[0] + " not found.");
        return;
      }
    } else {
      System.out.println("Guideline Parser :  Usage is one of:");
      System.out.println("         java GdlParser < inputfile");
      System.out.println("OR");
      System.out.println("         java GdlParser inputfile");
      return;
    }
    try {
      ASTCompilationUnit cu = parser.CompilationUnit();
      System.out.println("Guideline Parser :  Guideline parsed successfully.");
        dump(cu);
    } catch (ParseException e) {
      System.out.println("Guideline Parser :  Encountered errors during parse.");
      System.out.println(e.toString());
      System.out.println("Guideline Parser :  Encountered errors during parse.");
    }
  }

  public void dump() {
        ((SimpleNode)jjtree.rootNode()).dump(">");
  
  }
  
  public static void dump(ASTCompilationUnit cu) {
        DumpVisitor v=new DumpVisitor();
  
        System.out.println(cu.jjtAccept(v,null));
  //        ((SimpleNode)jjtree.rootNode()).dump(">");
      
    }
    

}

PARSER_END(GdlParser)

SKIP :
{
  " "
| "\t"
| "\r"
| "\n"
| <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}


TOKEN :  /* GDL Keywords */
{
  < ALIAS:    "alias">
| < INCLUDE:  "include">
| < IMPORT:   "import">
}



TOKEN :  /* GDL Keywords 2 */
{
  < DPM:      "dpm">
| < DSM:      "dsm">
| < PPM:      "ppm">
}



SPECIAL_TOKEN :  /* DPM Variable modifier */
{
  < DECISION: "decision">
}



TOKEN :  /* DPM Variable Types */
{
  < BOOLEAN:    "boolean">
| < DATE:       "date">
| < MONEY:      "money">
| < NUMERIC:    "numeric">
| < PERCENTAGE: "percentage">
| < TEXT:       "text">
}



TOKEN :  /* PPM Variable Types */
{
  < APPLICATION:"app">
| < CREDIT:     "crd">
| < PRODUCT:    "prd">
}



TOKEN :  /* Guideline Keywords */
{
  < GUIDELINE:  "guideline">
| < RULESET:    "ruleset">
| < RULE:       "rule">
| < MESSAGE:    "message">
| < IF:         "if">
| < THEN:       "then">
| < ELSE:       "else">
| < END:        "end">
| < TRUE:       ( "true" | "TRUE" ) >
| < FALSE:      ( "false" | "FALSE" ) >
| < CONTINUE:   "continue">
}



TOKEN :  /* Guideline 'Message' Keywords */
{
  < MSG_EXC:          "exception">
| < MSG_EXC_ASSETS:   "assets">
| < MSG_FINDINGS:     "findings">
| < MSG_OBSERVATION:  "observation">
| < MSG_CREDIT:       "credit">
}



TOKEN :
{ 
    < NUMERIC_CONSTANT: ( <INTEGER_LITERAL> | <FLOATING_POINT_LITERAL> ) >
}


TOKEN :
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
|
  < #DECIMAL_LITERAL: ["0"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )
      "'"
  >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
}


TOKEN :
{
  < FILENAME_LITERAL:
      "\""
      ( ["\\",".",":","/"]
      	| ["_","a"-"z","A"-"Z"]
        | ["0"-"9"]
      )*
      "\""
  >
}


TOKEN :   /* Seperators */
{
  < LPAREN:     "(" >
| < RPAREN:     ")" >
| < LBRACE:     "{" >
| < RBRACE:     "}" >
| < LBRACKET:   "[" >
| < RBRACKET:   "]" >
| < SEMICOLON:  ";" >
| < COMMA:      "," >
| < DOT:        "." >
}
  

TOKEN :   /* Special tokens */
{
  < PL:         "PL">
| < ASSIGN:     "=">
| < QUOTE:      "'">
| < DQUOTE:     "\"">
}
/* | < EOL:        "\n">
*/



TOKEN :  /* Math Operators */
{
  < PLUS:     "+" >
| < MINUS:    "-">
| < MULT:     "*">
| < DIV:      "/">
| < RAISETO:  "^">
}
  


TOKEN :  /* Equality Operators */
{
  < EQU:    "==" >
| < NEQ1:   "!=">
| < NEQ2:   "<>">
| < LT:     "<">
| < GT:     ">">
| < LEQ:    "<=">
| < GEQ:    ">=">
}
  



TOKEN :  /* Boolean Operators */
{
  < AND1:   "&&" >
| < AND2:   "and" >
| < OR1:    "||">
| < OR2:    "or">
}
  


/* IDENTIFIERS */

TOKEN :
{
  < IDENTIFIER: <LETTER> ( "-" | <LETTER>|<DIGIT>)* >
|
  < #LETTER:
      ["_","a"-"z","A"-"Z"]
  >
|
  < #DIGIT:
      ["0"-"9"]
  >
}


/* CompilationUnit */
ASTCompilationUnit CompilationUnit() :
{/*@bgen(jjtree) CompilationUnit */
  ASTCompilationUnit jjtn000 = new ASTCompilationUnit(JJTCOMPILATIONUNIT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CompilationUnit */
  try {
/*@egen*/
  ( VarDef() 
  | Alias() 
  | Import() 
  | Include() 
  | RuleDef() 
  | RulesetDef() )* 
  ( GuidelineDef() )? 
  <EOF>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}



void VarDef() :
{/*@bgen(jjtree) VarDef */
 ASTVarDef jjtn000 = new ASTVarDef(JJTVARDEF);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/String nm,typ;}
{/*@bgen(jjtree) VarDef */
  try {
/*@egen*/
  ( <DPM> typ=VarType(){jjtn000.data.put("ProductType",typ);jjtn000.data.put("Type","DPM");jjtn000.data.put("varType","DPM");} nm=Name(){jjtn000.data.put("Name",nm);} EOS() )
  | ( <PPM> typ=PpmVarType(){jjtn000.data.put("Type",typ);jjtn000.data.put("varType","PPM");} nm=Name(){jjtn000.data.put("Name",nm);} EOS() )/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

String VarType()       :
{}
{
  <BOOLEAN>       { return new String("1");}
  | <DATE>        { return new String("2");}
  | <MONEY>       { return new String("3");}
  | <NUMERIC>     { return new String("4");}
  | <PERCENTAGE>  { return new String("5");}
  | <TEXT>        { return new String("6");}
} 


String PpmVarType()       :
{}
{
  <APPLICATION> 	{ return new String("APP");}
  | <CREDIT>      	{ return new String("CRD");}
  | <PRODUCT>     	{ return new String("PRD");}
}




void Alias() :
{/*@bgen(jjtree) Alias */
 ASTAlias jjtn000 = new ASTAlias(JJTALIAS);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/String nm;}
{/*@bgen(jjtree) Alias */
  try {
/*@egen*/
  <ALIAS> <LPAREN> AliasType() "," nm=Name(){jjtn000.data.put("Name",nm);} "," AliasOf() <RPAREN> EOS()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}



void AliasType() :
{/*@bgen(jjtree) AliasType */
  ASTAliasType jjtn000 = new ASTAliasType(JJTALIASTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) AliasType */
  try {
/*@egen*/
  t=<RULE>/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/        { jjtn000.data.put("value",token.image);}
  | t=<RULESET>/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/   { jjtn000.data.put("value",token.image);}
  | t=<DPM>/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/       { jjtn000.data.put("value",token.image);}
  | t=<PPM>/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/       { jjtn000.data.put("value",token.image);}/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ 
}



void AliasOf() :
{/*@bgen(jjtree) AliasOf */
  ASTAliasOf jjtn000 = new ASTAliasOf(JJTALIASOF);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AliasOf */
  try {
/*@egen*/
  StringLiteral()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ 
}



void EOS()       :
{}
{
  ( ";" )
}


void Import() :
{/*@bgen(jjtree) Import */
 ASTImport jjtn000 = new ASTImport(JJTIMPORT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/String it,fn;}
{/*@bgen(jjtree) Import */
  try {
/*@egen*/
  <IMPORT> <LPAREN> (it=ImportType(){jjtn000.data.put("importType",it);}) "," (fn=Filename(){jjtn000.data.put("filename",fn);}) <RPAREN> EOS()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


String Filename()       :
{}
{
  <FILENAME_LITERAL> { return token.image;}
}


String ImportType()       :
{}
{
  ( <DPM>
  | <PPM>
  ) { return token.image;}
}


void Include() :
{/*@bgen(jjtree) Include */
 ASTInclude jjtn000 = new ASTInclude(JJTINCLUDE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/String fn;}
{/*@bgen(jjtree) Include */
  try {
/*@egen*/
  <INCLUDE> fn=ParenFilenameLiteral(){jjtn000.data.put("filename",fn);} EOS()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


String ParenFilenameLiteral()       :
{String fn;}
{
  ( ( <LPAREN> fn=Filename() <RPAREN> ) | fn=Filename() ){ return fn;}
}

String ParenStringLiteral()       :
{String str;}
{
  ( ( <LPAREN> str=StringLiteral() <RPAREN> ) | str=StringLiteral() ){ return str;} 
}

void GuidelineDef() :
{/*@bgen(jjtree) GuidelineDef */
 ASTGuidelineDef jjtn000 = new ASTGuidelineDef(JJTGUIDELINEDEF);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/String nm;} 
{/*@bgen(jjtree) GuidelineDef */
  try {
/*@egen*/
  <GUIDELINE> ( <LPAREN> nm=ParenStringLiteral() <RPAREN> ){jjtn000.data.put("Name",nm);jjtn000.data.put("GuidelineID","1");jjtn000.data.put("Version","1");jjtn000.data.put("StartDate","");}   
  ( ( LOOKAHEAD(4)
    RulesetDef() 
  | RulesetRef()  )
  | ( LOOKAHEAD(5)
    RuleRef() 
  | RuleDef() ) )+ 

  <END>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ 
}




String StringLiteral()       : 
{}
{
  <STRING_LITERAL>  { return token.image;}
}

String Name()       :
{}
{
  <IDENTIFIER> {  return token.image; }
}

void RulesetDef() :
{/*@bgen(jjtree) RulesetDef */
 ASTRulesetDef jjtn000 = new ASTRulesetDef(JJTRULESETDEF);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/String nm, et;}
{/*@bgen(jjtree) RulesetDef */
  try {
/*@egen*/
  "ruleset" nm=Name(){jjtn000.data.put("Name",nm);jjtn000.data.put("Id","99999");jjtn000.data.put("Type","0");} <LPAREN> ( et=ExecuteType(){jjtn000.data.put("ExecuteType",et);} ) ( "," <PL> )? <RPAREN>
  (LOOKAHEAD(5) RuleDef()
    | RuleRef() )+ 
  <END>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}



String ExecuteType()       :
{}
{
  <TRUE>        { return new String("1");} 
  | <FALSE>     { return new String("2");} 
  | <CONTINUE>  { return new String("3");} 
}



void RulesetRef() :
{/*@bgen(jjtree) RulesetRef */
 ASTRulesetRef jjtn000 = new ASTRulesetRef(JJTRULESETREF);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/String nm;}
{/*@bgen(jjtree) RulesetRef */
  try {
/*@egen*/
  "ruleset" nm=Name(){jjtn000.data.put("Name",nm);} <LPAREN> <RPAREN> EOS()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}



void RuleDef() :
{/*@bgen(jjtree) RuleDef */
 ASTRuleDef jjtn000 = new ASTRuleDef(JJTRULEDEF);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/String nm;}
{/*@bgen(jjtree) RuleDef */
  try {
/*@egen*/
  "rule" nm=Name(){jjtn000.data.put("Name",nm);jjtn000.data.put("Id","99999");} <LPAREN> <RPAREN>
  ( IfThenElse() )
  <END>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}



void RuleRef() :
{/*@bgen(jjtree) RuleRef */
 ASTRuleRef jjtn000 = new ASTRuleRef(JJTRULEREF);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/String nm;}
{/*@bgen(jjtree) RuleRef */
  try {
/*@egen*/
  "rule" nm=Name(){jjtn000.data.put("Name",nm);} <LPAREN> <RPAREN> EOS()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}



void IfThenElse()       :
{}
{
  "if" <LPAREN> Condition() <RPAREN>
  "then"
  IfActions()
  ( <ELSE> 
    ElseActions()
  )?
  <END>
 
}

// COMPARISON EXPRESSIONS

/*
Condition  --> CompTerm ( AND1 CompTerm | AND2 CompTerm | OR1 CompTerm | OR2 CompTerm )*
*/
void Condition() :
{/*@bgen(jjtree) Condition */
  ASTCondition jjtn000 = new ASTCondition(JJTCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Condition */
  try {
/*@egen*/
  Expression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/*
Expression  --> CompTerm ( AND1 CompTerm | AND2 CompTerm | OR1 CompTerm | OR2 CompTerm )*
*/
void Expression() :
{/*@bgen(jjtree) Expression */
  ASTExpression jjtn000 = new ASTExpression(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}  
{/*@bgen(jjtree) Expression */
  try {
/*@egen*/
  Compute()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/*
Compute  --> CompTerm ( AND1 CompTerm | AND2 CompTerm | OR1 CompTerm | OR2 CompTerm )*
*/
void Compute()                     :
{/*@bgen(jjtree) #LogicalCompute(> 1) */
  ASTLogicalCompute jjtn000 = new ASTLogicalCompute(JJTLOGICALCOMPUTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #LogicalCompute(> 1) */
  try {
/*@egen*/
  CompTerm() ( LogicalOperator() CompTerm() )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/
}



void LogicalOperator() :
{/*@bgen(jjtree) LogicalOperator */
  ASTLogicalOperator jjtn000 = new ASTLogicalOperator(JJTLOGICALOPERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) LogicalOperator */
  try {
/*@egen*/
  ( t=<AND1>
  | t=<AND2>
  | t=<OR1>
  | t=<OR2> )/*@bgen(jjtree)*/
              {
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
              }
/*@egen*/ { jjtn000.data.put("value", t.image ); }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}



/*
CompTerm  --> Primary ( LT Primary 
            | GT Primary
            | NEQ1 Primary
            | NEQ2 Primary
            | EQU Primary
            | LEQ Primary
            | GEQ Primary)*

*/
void CompTerm()                      :
{/*@bgen(jjtree) #EqualityCompute(> 1) */
  ASTEqualityCompute jjtn000 = new ASTEqualityCompute(JJTEQUALITYCOMPUTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #EqualityCompute(> 1) */
  try {
/*@egen*/
  Operand() ( EqualityOperator() Operand() )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/
 
}



void EqualityOperator() :
{/*@bgen(jjtree) EqualityOperator */
  ASTEqualityOperator jjtn000 = new ASTEqualityOperator(JJTEQUALITYOPERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) EqualityOperator */
  try {
/*@egen*/
  ( t=<LT>
  | t=<GT>
  | t=<NEQ1>
  | t=<NEQ2>
  | t=<EQU>
  | t=<LEQ>
  | t=<GEQ> )/*@bgen(jjtree)*/
              {
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
              }
/*@egen*/ { jjtn000.data.put("value", t.image ); }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}



/*
Operand   --> NUMERIC_CONSTANT
        | STRING_LITERAL
        | VarRef
        | LPAREN Compute RPAREN

*/

void Operand()       :
{}
{
  ( Constant()
    | VarRef()
    | Brace()
  )
}




void Brace() :
{/*@bgen(jjtree) Brace */
  ASTBrace jjtn000 = new ASTBrace(JJTBRACE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Brace */
  try {
/*@egen*/
  <LPAREN> Compute() <RPAREN>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}




void Constant() :
{/*@bgen(jjtree) Constant */
  ASTConstant jjtn000 = new ASTConstant(JJTCONSTANT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Constant */
  try {
/*@egen*/
  ( t=<NUMERIC_CONSTANT>
  | t=<STRING_LITERAL> )/*@bgen(jjtree)*/
                         {
                           jjtree.closeNodeScope(jjtn000, true);
                           jjtc000 = false;
                         }
/*@egen*/ { jjtn000.data.put("value",t.image ); }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}



// MATH EXPRESSIONS

/*
MathExpression  --> MathTerm ( PLUS MathTerm | MINUS MathTerm )*
*/
void MathExpression() :
{/*@bgen(jjtree) MathExpression */
  ASTMathExpression jjtn000 = new ASTMathExpression(JJTMATHEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MathExpression */
  try {
/*@egen*/
  /*MathCompute() ( PlusOperator() MathCompute() | MinusOperator() MathCompute() )*  */
  MCompute()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


/*
MCompute  --> MathTerm ( PLUS MathTerm | MINUS MathTerm )*
*/
void MCompute()                  :
{/*@bgen(jjtree) #MathCompute(> 1) */
  ASTMathCompute jjtn000 = new ASTMathCompute(JJTMATHCOMPUTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #MathCompute(> 1) */
  try {
/*@egen*/
  MathCompute() ( PlusOperator() MathCompute() | MinusOperator() MathCompute() )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/  
}


/*
PlusOperator - This is here so that the tree builds correctly and the 
                operator can be retrieved.
*/
void PlusOperator() :
{/*@bgen(jjtree) PlusOperator */
  ASTPlusOperator jjtn000 = new ASTPlusOperator(JJTPLUSOPERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) PlusOperator */
  try {
/*@egen*/
  t=<PLUS>/*@bgen(jjtree)*/
           {
             jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
           }
/*@egen*/ {jjtn000.data.put("value", t.image ); }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}



/*
MinusOperator - This is here so that the tree builds correctly and the 
                operator can be retrieved.
*/
void MinusOperator() :
{/*@bgen(jjtree) MinusOperator */
  ASTMinusOperator jjtn000 = new ASTMinusOperator(JJTMINUSOPERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) MinusOperator */
  try {
/*@egen*/
  t=<MINUS>/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn000, true);
              jjtc000 = false;
            }
/*@egen*/ {jjtn000.data.put("value", t.image ); }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}



/*
MathCompute    --> MTerm ( MULT MTerm | DIV MTerm )*
*/
void MathCompute()                 :
{/*@bgen(jjtree) #MathCompute(> 1) */
  ASTMathCompute jjtn000 = new ASTMathCompute(JJTMATHCOMPUTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #MathCompute(> 1) */
  try {
/*@egen*/
  MultTerm() ( MultOperator() MultTerm() | DivOperator() MultTerm() )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/  
}


/*
MultOperator - This is here so that the tree builds correctly and the 
                operator can be retrieved.
*/
void MultOperator() :
{/*@bgen(jjtree) MultOperator */
  ASTMultOperator jjtn000 = new ASTMultOperator(JJTMULTOPERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) MultOperator */
  try {
/*@egen*/
  t=<MULT>/*@bgen(jjtree)*/
           {
             jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
           }
/*@egen*/ {jjtn000.data.put("value", t.image ); }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}



/*
DivOperator - This is here so that the tree builds correctly and the 
                operator can be retrieved.
*/
void DivOperator() :
{/*@bgen(jjtree) DivOperator */
  ASTDivOperator jjtn000 = new ASTDivOperator(JJTDIVOPERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) DivOperator */
  try {
/*@egen*/
  t=<DIV>/*@bgen(jjtree)*/
          {
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
          }
/*@egen*/ {jjtn000.data.put("value", t.image ); }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}



/*
MultTerm     --> MathOperand ( RAISETO MathOperand )*
*/
void MultTerm()                  :
{/*@bgen(jjtree) #MathCompute(> 1) */
  ASTMathCompute jjtn000 = new ASTMathCompute(JJTMATHCOMPUTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #MathCompute(> 1) */
  try {
/*@egen*/
  MathOperand() ( RaiseToOperator() MathOperand() )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/   
}


/*
RaiseToOperator - This is here so that the tree builds correctly and the 
                operator can be retrieved.
*/
void RaiseToOperator() :
{/*@bgen(jjtree) RaiseToOperator */
  ASTRaiseToOperator jjtn000 = new ASTRaiseToOperator(JJTRAISETOOPERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) RaiseToOperator */
  try {
/*@egen*/
  t=<RAISETO>/*@bgen(jjtree)*/
              {
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
              }
/*@egen*/ {jjtn000.data.put("value", t.image ); }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}



/*
MathOperand   --> NUMERIC_CONSTANT
          | LPAREN MathExpression RPAREN
          | MINUS MathOperand
          

*/
void MathOperand()       :
{}
{
//  ( <INTEGER_LITERAL> | <FLOATING_POINT_LITERAL> )
//  <NUMERIC_CONSTANT>
  MathConstant()
  | VarRef()
  | MathBrace()
  | ( <MINUS>  MathOperand() )
}



void MathBrace()        :
{/*@bgen(jjtree) Brace */
  ASTBrace jjtn000 = new ASTBrace(JJTBRACE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Brace */
  try {
/*@egen*/
//  ( <LPAREN> MathExpression() <RPAREN> )
  ( <LPAREN> MCompute() <RPAREN> )/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}




void MathConstant() :
{/*@bgen(jjtree) MathConstant */
  ASTMathConstant jjtn000 = new ASTMathConstant(JJTMATHCONSTANT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) MathConstant */
  try {
/*@egen*/
  t=<NUMERIC_CONSTANT>/*@bgen(jjtree)*/
                       {
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                       }
/*@egen*/ { jjtn000.data.put("value", t.image ); }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}



void IfActions() :
{/*@bgen(jjtree) IfActions */
  ASTIfActions jjtn000 = new ASTIfActions(JJTIFACTIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) IfActions */
  try {
/*@egen*/
  ( 
    Assign() 
  | Message() 
  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ 
}

void ElseActions() :
{/*@bgen(jjtree) ElseActions */
  ASTElseActions jjtn000 = new ASTElseActions(JJTELSEACTIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ElseActions */
  try {
/*@egen*/
  ( 
    Assign() 
  | Message() 
  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ 
}

void Assign() :
{/*@bgen(jjtree) Assign */
  ASTAssign jjtn000 = new ASTAssign(JJTASSIGN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Assign */
  try {
/*@egen*/
  AssignTo() <ASSIGN> AssignValue() EOS()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


void AssignTo() :
{/*@bgen(jjtree) AssignTo */
  ASTAssignTo jjtn000 = new ASTAssignTo(JJTASSIGNTO);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AssignTo */
  try {
/*@egen*/
  VarRef()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


void AssignValue() :
{/*@bgen(jjtree) AssignValue */
  ASTAssignValue jjtn000 = new ASTAssignValue(JJTASSIGNVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AssignValue */
  try {
/*@egen*/
  (LOOKAHEAD(2)
    MathExpression()
    | ConstantExpression()
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


void ConstantExpression()             :
{/*@bgen(jjtree) Expression */
  ASTExpression jjtn000 = new ASTExpression(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Expression */
  try {
/*@egen*/
  Constant()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}



void Message() :
{/*@bgen(jjtree) Message */
  ASTMessage jjtn000 = new ASTMessage(JJTMESSAGE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Message */
  try {
/*@egen*/
  "message" <LPAREN> ( ( Exptn() "," ExptnType() ) | MessageType() ) "," StringLiteral() <RPAREN> EOS()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Exptn() :
{/*@bgen(jjtree) Exptn */
  ASTExptn jjtn000 = new ASTExptn(JJTEXPTN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Exptn */
  try {
/*@egen*/
  <MSG_EXC>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


void ExptnType() :
{/*@bgen(jjtree) ExptnType */
  ASTExptnType jjtn000 = new ASTExptnType(JJTEXPTNTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t;}
{/*@bgen(jjtree) ExptnType */
  try {
/*@egen*/
  ( t=<MSG_EXC_ASSETS> | t=<MSG_EXC> )/*@bgen(jjtree)*/
                                       {
                                         jjtree.closeNodeScope(jjtn000, true);
                                         jjtc000 = false;
                                       }
/*@egen*/ { jjtn000.data.put("value", t.image); }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void MessageType() :
{/*@bgen(jjtree) MessageType */
  ASTMessageType jjtn000 = new ASTMessageType(JJTMESSAGETYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) MessageType */
  try {
/*@egen*/
  ( t=<MSG_FINDINGS> | t=<MSG_OBSERVATION> | t=<MSG_CREDIT> )/*@bgen(jjtree)*/
                                                              {
                                                                jjtree.closeNodeScope(jjtn000, true);
                                                                jjtc000 = false;
                                                              }
/*@egen*/ { jjtn000.data.put("value", t.image); }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


void VarRef() :
{/*@bgen(jjtree) VarRef */
 ASTVarRef jjtn000 = new ASTVarRef(JJTVARREF);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/String nm;}
{/*@bgen(jjtree) VarRef */
  try {
/*@egen*/
  nm=Name()/*@bgen(jjtree)*/
           {
             jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
           }
/*@egen*/{jjtn000.data.put("Name",nm);}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
//  ( VarCast() )? <IDENTIFIER>
}

void VarCast() :
{/*@bgen(jjtree) VarCast */
  ASTVarCast jjtn000 = new ASTVarCast(JJTVARCAST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VarCast */
  try {
/*@egen*/
  <LPAREN> VariableType() <RPAREN>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


void VariableType() :
{/*@bgen(jjtree) VariableType */
  ASTVariableType jjtn000 = new ASTVariableType(JJTVARIABLETYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VariableType */
  try {
/*@egen*/
  ( <DPM> | <DSM> | <PPM> )/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


void AndOperator() :
{/*@bgen(jjtree) AndOperator */
  ASTAndOperator jjtn000 = new ASTAndOperator(JJTANDOPERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AndOperator */
  try {
/*@egen*/
  <AND1>
| <AND2>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ 
}

void OrOperator() :
{/*@bgen(jjtree) OrOperator */
  ASTOrOperator jjtn000 = new ASTOrOperator(JJTOROPERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) OrOperator */
  try {
/*@egen*/
  <OR1> 
| <OR2>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ 
}

/* Example Rules/sets

rule G-TestRule ()
  if ( Loan_Amount == Loan_Amount )
  then
    Rate_1st = Rate_1st + Rate_Adj-Total
    Rate = Rate_1st
  else
    Rate_1st = 0
    Rate = 0
  end
end

rule G-TestRule2 ()
  if ( Loan_Amount_1st > 100000 &&
        ( Loan_Amount_1st < 200000 ||
          Loan_Amount_1st == 1 
        )
     )
  then
    Rate = Rate_1st
  end
end

ruleset CoolRuleset(true,0)

  rule G-TestRule3 ()
    if ( Loan_Amount == Loan_Amount )
    then
      Rate_1st = Rate_1st + Rate_Adj-Total; Rate = Rate_1st
    end
  end
  
  rule G-TestRule4 ()
    if ( Loan_Amount_1st > 100000 &&
          ( (Loan_Amount_1st < 200000) ||
            Loan_Amount_1st == 1 
          )
       )
    then
      Rate = Rate_1st;
    end
  end

end

*/