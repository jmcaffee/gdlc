/*
 */

options {
  MULTI = true;
  VISITOR = true;
  STATIC = false;
}

PARSER_BEGIN(GdlParser)

package runtime.parser;

import runtime.main.Log;
import runtime.parser.DumpVisitor;

public class GdlParser {

  public static void main(String args[]) {
    GdlParser parser;
    if (args.length == 0) {
      Log.status("Guideline Parser :  Reading from standard input . . .");
      parser = new GdlParser(System.in);
    } else if (args.length == 1) {
      Log.status("Guideline Parser :  Reading from file " + args[0] + " . . .");
      try {
        parser = new GdlParser(new java.io.FileInputStream(args[0]));
      } catch (java.io.FileNotFoundException e) {
        Log.error("Guideline Parser :  File " + args[0] + " not found.");
        return;
      }
    } else {
      System.out.println("Guideline Parser :  Usage is one of:");
      System.out.println("         java GdlParser < inputfile");
      System.out.println("OR");
      System.out.println("         java GdlParser inputfile");
      return;
    }
    try {
      ASTCompilationUnit cu = parser.CompilationUnit();
      Log.status("Guideline Parser :  Guideline parsed successfully.");
        dump(cu);
    } catch (ParseException e) {
      Log.error("Guideline Parser :  Encountered errors during parse.");
      Log.error(e.toString());
    }
  }

  public void dump() {
        ((SimpleNode)jjtree.rootNode()).dump(">");
  
  }
  
  public static void dump(ASTCompilationUnit cu) {
        DumpVisitor v=new DumpVisitor();
  
        System.out.println(cu.jjtAccept(v,null));
  //        ((SimpleNode)jjtree.rootNode()).dump(">");
      
    }
    

}

PARSER_END(GdlParser)

SKIP :
{
  " "
| "\t"
| "\r"
| "\n"
| <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}


TOKEN :  /* GDL Keywords */
{
  < ALIAS:    "alias">
| < INCLUDE:  "include">
| < IMPORT:   "import">
}



TOKEN :  /* GDL Keywords 2 */
{
  < DPM:      "dpm">
| < DSM:      "dsm">
| < PPM:      "ppm">
}



SPECIAL_TOKEN :  /* DPM Variable modifier */
{
  < DECISION: "decision">
}



TOKEN :  /* DPM Variable Types */
{
  < BOOLEAN:    "boolean">
| < DATE:       "date">
| < MONEY:      "money">
| < NUMERIC:    "numeric">
| < PERCENTAGE: "percentage">
| < TEXT:       "text">
}



TOKEN :  /* PPM Variable Types */
{
  < APPLICATION:"app">
| < CREDIT:     "crd">
| < PRODUCT:    "prd">
}



TOKEN :  /* Guideline Keywords */
{
  < GUIDELINE:  "guideline">
| < RULESET:    "ruleset">
| < RULE:       "rule">
| < MESSAGE:    "message">
| < IF:         "if">
| < THEN:       "then">
| < ELSE:       "else">
| < END:        "end">
| < TRUE:       ( "true" | "TRUE" ) >
| < FALSE:      ( "false" | "FALSE" ) >
| < CONTINUE:   "continue">
}



TOKEN :  /* Guideline 'Message' Keywords */
{
  < MSG_EXC:          "exception">
| < MSG_EXC_ASSETS:   "assets">
| < MSG_FINDINGS:     "findings">
| < MSG_OBSERVATION:  "observation">
| < MSG_CREDIT:       "credit">
}



TOKEN :
{ 
    < NUMERIC_CONSTANT: ( <INTEGER_LITERAL> | <FLOATING_POINT_LITERAL> ) >
}


TOKEN :
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
|
  < #DECIMAL_LITERAL: ["0"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )
      "'"
  >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
}


TOKEN :
{
  < FILENAME_LITERAL:
      "\""
      ( ["\\",".",":","/"]
      	| ["_","a"-"z","A"-"Z"]
        | ["0"-"9"]
      )*
      "\""
  >
}


TOKEN :   /* Seperators */
{
  < LPAREN:     "(" >
| < RPAREN:     ")" >
| < LBRACE:     "{" >
| < RBRACE:     "}" >
| < LBRACKET:   "[" >
| < RBRACKET:   "]" >
| < SEMICOLON:  ";" >
| < COMMA:      "," >
| < DOT:        "." >
}
  

TOKEN :   /* Special tokens */
{
  < PL:         "PL">
| < ASSIGN:     "=">
| < QUOTE:      "'">
| < DQUOTE:     "\"">
}
/* | < EOL:        "\n">
*/



TOKEN :  /* Math Operators */
{
  < PLUS:     "+" >
| < MINUS:    "-">
| < MULT:     "*">
| < DIV:      "/">
| < RAISETO:  "^">
}
  


TOKEN :  /* Equality Operators */
{
  < EQU:    "==" >
| < NEQ1:   "!=">
| < NEQ2:   "<>">
| < LT:     "<">
| < GT:     ">">
| < LEQ:    "<=">
| < GEQ:    ">=">
}
  



TOKEN :  /* Boolean Operators */
{
  < AND1:   "&&" >
| < AND2:   "and" >
| < OR1:    "||">
| < OR2:    "or">
}
  


/* IDENTIFIERS */

TOKEN :
{
  < IDENTIFIER: <LETTER> ( "-" | <LETTER>|<DIGIT>)* >
|
  < #LETTER:
      ["_","a"-"z","A"-"Z"]
  >
|
  < #DIGIT:
      ["0"-"9"]
  >
}


/* CompilationUnit */
ASTCompilationUnit CompilationUnit() :
{}
{
  ( VarDef() 
  | Alias() 
  | Import() 
  | Include() 
  | RuleDef() 
  | RulesetDef() )* 
  ( GuidelineDef() )? 
  <EOF>  
  { return jjtThis; }
}



void VarDef() :
{String nm,typ;}
{
  ( <DPM> typ=VarType(){jjtThis.data.put("ProductType",typ);jjtThis.data.put("Type","DPM");jjtThis.data.put("varType","DPM");} nm=Name(){jjtThis.data.put("Name",nm);} EOS() )
  | ( <PPM> typ=PpmVarType(){jjtThis.data.put("Type",typ);jjtThis.data.put("varType","PPM");} nm=Name(){jjtThis.data.put("Name",nm);} EOS() )
}

String VarType() #void :
{}
{
  <BOOLEAN>       { return new String("1");}
  | <DATE>        { return new String("2");}
  | <MONEY>       { return new String("3");}
  | <NUMERIC>     { return new String("4");}
  | <PERCENTAGE>  { return new String("5");}
  | <TEXT>        { return new String("6");}
} 


String PpmVarType() #void :
{}
{
  <APPLICATION> 	{ return new String("APP");}
  | <CREDIT>      	{ return new String("CRD");}
  | <PRODUCT>     	{ return new String("PRD");}
}




void Alias() :
{String nm;}
{
  <ALIAS> <LPAREN> AliasType() "," nm=Name(){jjtThis.data.put("Name",nm);} "," AliasOf() <RPAREN> EOS()
}



void AliasType() :
{ Token t; }
{
  t=<RULE>        { jjtThis.data.put("value",token.image);}
  | t=<RULESET>   { jjtThis.data.put("value",token.image);}
  | t=<DPM>       { jjtThis.data.put("value",token.image);}
  | t=<PPM>       { jjtThis.data.put("value",token.image);} 
}



void AliasOf() :
{}
{
  StringLiteral() 
}



void EOS() #void :
{}
{
  ( ";" )
}


void Import() :
{String it,fn;}
{
  <IMPORT> <LPAREN> (it=ImportType(){jjtThis.data.put("importType",it);}) "," (fn=Filename(){jjtThis.data.put("filename",fn);}) <RPAREN> EOS()
}


String Filename() #void :
{}
{
  <FILENAME_LITERAL> { return token.image;}
}


String ImportType() #void :
{}
{
  ( <DPM>
  | <PPM>
  ) { return token.image;}
}


void Include() :
{String fn;}
{
  <INCLUDE> fn=ParenFilenameLiteral(){jjtThis.data.put("filename",fn);} EOS()
}


String ParenFilenameLiteral() #void :
{String fn;}
{
  ( ( <LPAREN> fn=Filename() <RPAREN> ) | fn=Filename() ){ return fn;}
}

String ParenStringLiteral() #void :
{String str;}
{
  ( ( <LPAREN> str=StringLiteral() <RPAREN> ) | str=StringLiteral() ){ return str;} 
}

void GuidelineDef() :
{String nm;} 
{
  <GUIDELINE> ( <LPAREN> nm=ParenStringLiteral() <RPAREN> ){jjtThis.data.put("Name",nm);jjtThis.data.put("GuidelineID","1");jjtThis.data.put("Version","1");jjtThis.data.put("StartDate","");}   
  ( ( LOOKAHEAD(4)
    RulesetDef() 
  | RulesetRef()  )
  | ( LOOKAHEAD(5)
    RuleRef() 
  | RuleDef() ) )+ 

  <END> 
}




String StringLiteral() #void : 
{}
{
  <STRING_LITERAL>  { return token.image;}
}

String Name() #void :
{}
{
  <IDENTIFIER> {  return token.image; }
}

void RulesetDef() :
{String nm, et;}
{
  "ruleset" nm=Name(){jjtThis.data.put("Name",nm);jjtThis.data.put("Id","99999");jjtThis.data.put("Type","0");} <LPAREN> ( et=ExecuteType(){jjtThis.data.put("ExecuteType",et);} ) ( "," <PL> )? <RPAREN>
  (LOOKAHEAD(5) RuleDef()
    | RuleRef() )+ 
  <END>
}



String ExecuteType() #void :
{}
{
  <TRUE>        { return new String("1");} 
  | <FALSE>     { return new String("2");} 
  | <CONTINUE>  { return new String("3");} 
}



void RulesetRef() :
{String nm;}
{
  "ruleset" nm=Name(){jjtThis.data.put("Name",nm);} <LPAREN> <RPAREN> EOS()
}



void RuleDef() :
{String nm;}
{
  "rule" nm=Name(){jjtThis.data.put("Name",nm);jjtThis.data.put("Id","99999");} <LPAREN> <RPAREN>
  ( IfThenElse() )
  <END>
}



void RuleRef() :
{String nm;}
{
  "rule" nm=Name(){jjtThis.data.put("Name",nm);} <LPAREN> <RPAREN> EOS()
}



void IfThenElse() #void :
{}
{
  "if" <LPAREN> Condition() <RPAREN>
  "then"
  IfActions()
  ( <ELSE> 
    ElseActions()
  )?
  <END>
 
}

// COMPARISON EXPRESSIONS

/*
Condition  --> CompTerm ( AND1 CompTerm | AND2 CompTerm | OR1 CompTerm | OR2 CompTerm )*
*/
void Condition() :
{}
{
  Expression()
}

/*
Expression  --> CompTerm ( AND1 CompTerm | AND2 CompTerm | OR1 CompTerm | OR2 CompTerm )*
*/
void Expression() :
{}  
{
  Compute()
}

/*
Compute  --> CompTerm ( AND1 CompTerm | AND2 CompTerm | OR1 CompTerm | OR2 CompTerm )*
*/
void Compute() #LogicalCompute(>1) :
{}
{
  CompTerm() ( LogicalOperator() CompTerm() )*
}



void LogicalOperator() :
{ Token t; }
{
  ( t=<AND1>
  | t=<AND2>
  | t=<OR1>
  | t=<OR2> ) { jjtThis.data.put("value", t.image ); }
}



/*
CompTerm  --> Primary ( LT Primary 
            | GT Primary
            | NEQ1 Primary
            | NEQ2 Primary
            | EQU Primary
            | LEQ Primary
            | GEQ Primary)*

*/
void CompTerm() #EqualityCompute(>1) :
{}
{
  Operand() ( EqualityOperator() Operand() )*
 
}



void EqualityOperator() :
{ Token t; }
{
  ( t=<LT>
  | t=<GT>
  | t=<NEQ1>
  | t=<NEQ2>
  | t=<EQU>
  | t=<LEQ>
  | t=<GEQ> ) { jjtThis.data.put("value", t.image ); }
}



/*
Operand   --> NUMERIC_CONSTANT
        | STRING_LITERAL
        | VarRef
        | LPAREN Compute RPAREN

*/

void Operand() #void :
{}
{
  ( Constant()
    | VarRef()
    | Brace()
  )
}




void Brace() :
{}
{
  <LPAREN> Compute() <RPAREN>
}




void Constant() :
{ Token t; }
{
  ( t=<NUMERIC_CONSTANT>
  | t=<STRING_LITERAL> ) { jjtThis.data.put("value",t.image ); }
}



// MATH EXPRESSIONS

/*
MathExpression  --> MathTerm ( PLUS MathTerm | MINUS MathTerm )*
*/
void MathExpression() :
{}
{
  /*MathCompute() ( PlusOperator() MathCompute() | MinusOperator() MathCompute() )*  */
  MCompute()
}


/*
MCompute  --> MathTerm ( PLUS MathTerm | MINUS MathTerm )*
*/
void MCompute() #MathCompute(>1) :
{}
{
  MathCompute() ( PlusOperator() MathCompute() | MinusOperator() MathCompute() )*  
}


/*
PlusOperator - This is here so that the tree builds correctly and the 
                operator can be retrieved.
*/
void PlusOperator() :
{ Token t; }
{
  t=<PLUS> {jjtThis.data.put("value", t.image ); }
}



/*
MinusOperator - This is here so that the tree builds correctly and the 
                operator can be retrieved.
*/
void MinusOperator() :
{ Token t; }
{
  t=<MINUS> {jjtThis.data.put("value", t.image ); }
}



/*
MathCompute    --> MTerm ( MULT MTerm | DIV MTerm )*
*/
void MathCompute() #MathCompute(>1):
{}
{
  MultTerm() ( MultOperator() MultTerm() | DivOperator() MultTerm() )*  
}


/*
MultOperator - This is here so that the tree builds correctly and the 
                operator can be retrieved.
*/
void MultOperator() :
{ Token t; }
{
  t=<MULT> {jjtThis.data.put("value", t.image ); }
}



/*
DivOperator - This is here so that the tree builds correctly and the 
                operator can be retrieved.
*/
void DivOperator() :
{ Token t; }
{
  t=<DIV> {jjtThis.data.put("value", t.image ); }
}



/*
MultTerm     --> MathOperand ( RAISETO MathOperand )*
*/
void MultTerm() #MathCompute(>1) :
{}
{
  MathOperand() ( RaiseToOperator() MathOperand() )*   
}


/*
RaiseToOperator - This is here so that the tree builds correctly and the 
                operator can be retrieved.
*/
void RaiseToOperator() :
{ Token t; }
{
  t=<RAISETO> {jjtThis.data.put("value", t.image ); }
}



/*
MathOperand   --> NUMERIC_CONSTANT
          | LPAREN MathExpression RPAREN
          | MINUS MathOperand
          

*/
void MathOperand() #void :
{}
{
//  ( <INTEGER_LITERAL> | <FLOATING_POINT_LITERAL> )
//  <NUMERIC_CONSTANT>
  MathConstant()
  | VarRef()
  | MathBrace()
  | ( <MINUS>  MathOperand() )
}



void MathBrace() #Brace :
{}
{
//  ( <LPAREN> MathExpression() <RPAREN> )
  ( <LPAREN> MCompute() <RPAREN> )
}




void MathConstant() :
{ Token t; }
{
  t=<NUMERIC_CONSTANT> { jjtThis.data.put("value", t.image ); }
}



void IfActions() :
{}
{
  ( 
    Assign() 
  | Message() 
  )* 
}

void ElseActions() :
{}
{
  ( 
    Assign() 
  | Message() 
  )* 
}

void Assign() :
{}
{
  AssignTo() <ASSIGN> AssignValue() EOS()
}


void AssignTo() :
{}
{
  VarRef()
}


void AssignValue() :
{}
{
  (LOOKAHEAD(2)
    MathExpression()
    | ConstantExpression()
  )
}


void ConstantExpression() #Expression :
{}
{
  Constant()
}



void Message() :
{}
{
  "message" <LPAREN> ( ( Exptn() "," ExptnType() ) | MessageType() ) "," StringLiteral() <RPAREN> EOS()
}

void Exptn() :
{}
{
  <MSG_EXC>
}


void ExptnType() :
{ Token t;}
{
  ( t=<MSG_EXC_ASSETS> | t=<MSG_EXC> ) { jjtThis.data.put("value", t.image); }
}

void MessageType() :
{ Token t; }
{
  ( t=<MSG_FINDINGS> | t=<MSG_OBSERVATION> | t=<MSG_CREDIT> ) { jjtThis.data.put("value", t.image); }
}


void VarRef() :
{String nm;}
{
  nm=Name(){jjtThis.data.put("Name",nm);}
//  ( VarCast() )? <IDENTIFIER>
}

void VarCast() :
{}
{
  <LPAREN> VariableType() <RPAREN>
}


void VariableType() :
{}
{
  ( <DPM> | <DSM> | <PPM> )
}


void AndOperator() :
{}
{
  <AND1>
| <AND2> 
}

void OrOperator() :
{}
{
  <OR1> 
| <OR2> 
}

/* Example Rules/sets

rule G-TestRule ()
  if ( Loan_Amount == Loan_Amount )
  then
    Rate_1st = Rate_1st + Rate_Adj-Total
    Rate = Rate_1st
  else
    Rate_1st = 0
    Rate = 0
  end
end

rule G-TestRule2 ()
  if ( Loan_Amount_1st > 100000 &&
        ( Loan_Amount_1st < 200000 ||
          Loan_Amount_1st == 1 
        )
     )
  then
    Rate = Rate_1st
  end
end

ruleset CoolRuleset(true,0)

  rule G-TestRule3 ()
    if ( Loan_Amount == Loan_Amount )
    then
      Rate_1st = Rate_1st + Rate_Adj-Total; Rate = Rate_1st
    end
  end
  
  rule G-TestRule4 ()
    if ( Loan_Amount_1st > 100000 &&
          ( (Loan_Amount_1st < 200000) ||
            Loan_Amount_1st == 1 
          )
       )
    then
      Rate = Rate_1st;
    end
  end

end

*/